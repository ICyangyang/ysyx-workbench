## 三个对调试有用的宏Log\Assert\panic
- Log()是printf()的升级版, 专门用来输出调试信息, 同时还会输出使用Log()所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置
- Assert()是assert()的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息
- panic()用于输出信息并结束程序, 相当于无条件的assertion fail
## vaddr_read/write、vaddr/paddr
- 在客户程序运行的过程中, 总是使用vaddr_read()和vaddr_write()来访问模拟的内存.
- vaddr虚拟地址, paddr物理地址
## Read the F* Source Code,RTFSC
- 只有一两个源文件, 代码只有几百行的项目, 直接RTFSC有效果. 但如果源文件更多, 代码量更大, 这种做法效率很低, 因为人脑的短期记忆能力有限, 即使是静态的代码也无法完全记住, 更何况程序的动态行为是一个巨大的状态机, 大脑在一段时间内只能模拟出状态机很小的一部分.
- 用GDB模拟状态机。
  > 在GDB中, 我们可以通过单步执行的方式让程序一次执行一条指令, 相当于让状态机一次只前进一步, 这样我们就可以观察程序任意时刻的状态了!
  
  > 状态机前进的轨迹就是程序执行的真实顺序, 于是你就可以一边运行程序一边理解程序的行为了
  
  > 尤其是函数指针, 因为你从静态代码上很可能看不出来程序运行的时候这个指针会指向哪个函数.
## GDB调试工具
- GDB自带TUI界面. 在一个高度较高的窗口中运行GDB, 输入layout split就可以切换到TUI,可以同时从源代码和指令的角度来观察程序的行为. 不过为了看到源代码, 还需要在编译NEMU时添加GDB调试信息
- 多认识GDB的一些命令和操作, 比如:
  - 单步执行进入你感兴趣的函数
  - 单步执行跳过你不感兴趣的函数(例如库函数)
  - 运行到函数末尾
  - 打印变量或寄存器的值
  - 扫描内存
  - 查看调用栈
  - 设置断点
  - 设置监视点





  
# 参考链接
1. [PA1-开天辟地的篇章: 最简单的计算机-RTFSC](https://ysyx.oscc.cc/docs/ics-pa/1.3.html)
2. [GDB debugging tutorial for beginners](https://linuxconfig.org/gdb-debugging-tutorial-for-beginners)
